{"name":"f96289be8d","creation":"2024-11-20 11:41:46.590449","modified":"2024-11-20 11:41:46.590449","modified_by":"deploymentmaster@lmnas.com","owner":"deploymentmaster@lmnas.com","docstatus":0,"idx":0,"deleted_name":"Design Losses Defaults Beta","deleted_doctype":"Client Script","restored":0,"new_name":null,"data":"{\n \"creation\": \"2024-11-20 11:41:38.617952\",\n \"docstatus\": 0,\n \"doctype\": \"Client Script\",\n \"dt\": \"Design\",\n \"enabled\": 1,\n \"idx\": 0,\n \"modified\": \"2024-11-20 11:41:38.617952\",\n \"modified_by\": \"deploymentmaster@lmnas.com\",\n \"module\": null,\n \"name\": \"Design Losses Defaults Beta\",\n \"owner\": \"deploymentmaster@lmnas.com\",\n \"script\": \"frappe.ui.form.on(\\\"Design\\\", {\\n  /*\\n   * This function is to compute the custom losses\\n   * @params frm\\n   * @params iLossesSetting field as defined in the Gitra Settings\\n   */\\n  fnComputeCustomLosses(frm, iLossesSetting) {\\n    const LOSSES_SETTINGS = iLossesSetting.filter(\\n      (item) => item.transformer_type === frm.doc.transformer_type\\n    );\\n    // Sort iLossesSetting by rating, which is\\n    //defined as a Data type in the Rating Doctype\\n    LOSSES_SETTINGS.sort((a, b) => {\\n      const L_NUMA = parseInt(a.rating, 10);\\n      const L_NUMB = parseInt(b.rating, 10);\\n      if (L_NUMA < L_NUMB) {\\n        return -1;\\n      }\\n      if (L_NUMA > L_NUMB) {\\n        return 1;\\n      }\\n      return 0;\\n    });\\n    // Convert the rating from the form to a decimal (base 10) integer\\n    const L_RATING_INT = parseInt(frm.doc.rating, 10);\\n    // Find the first index with a rating larger than frm.doc.rating\\n    const L_INDEX = LOSSES_SETTINGS.findIndex(\\n      (x) => parseInt(x.rating, 10) > L_RATING_INT\\n    );\\n\\n    // Initialize an empty dict for ldCustomLosses\\n    var ldCustomLosses = {\\n      no_load_loss: \\\"\\\",\\n      load_loss: \\\"\\\",\\n      lwa: \\\"\\\",\\n      lpa_distance: \\\"\\\",\\n      lpa: \\\"\\\",\\n    };\\n\\n    if (L_INDEX > 0) {\\n      //Get the higher rating loss from gitra settings\\n      const L_RATING_LOSSES_HIGHER = LOSSES_SETTINGS[L_INDEX];\\n\\n      //Get the lower rating lossgitra  setting\\n      //(one place before the higher rating)\\n      const L_RATING_LOSSES_LOWER = LOSSES_SETTINGS[L_INDEX - 1];\\n\\n      //computing arithmetic average\\n      const L_ARITHMETIC_AVERAGE =\\n        (frm.doc.rating - L_RATING_LOSSES_LOWER.rating) /\\n        (L_RATING_LOSSES_HIGHER.rating - L_RATING_LOSSES_LOWER.rating);\\n      //append the value\\n      ldCustomLosses = {\\n        no_load_loss: Math.round(\\n          L_RATING_LOSSES_LOWER.no_load_loss +\\n            L_ARITHMETIC_AVERAGE *\\n              (L_RATING_LOSSES_HIGHER.no_load_loss -\\n                L_RATING_LOSSES_LOWER.no_load_loss)\\n        ),\\n        load_loss: Math.round(\\n          L_RATING_LOSSES_LOWER.load_loss +\\n            L_ARITHMETIC_AVERAGE *\\n              (L_RATING_LOSSES_HIGHER.load_loss -\\n                L_RATING_LOSSES_LOWER.load_loss)\\n        ),\\n        rating: frm.doc.rating,\\n        lwa: L_RATING_LOSSES_LOWER.lwa,\\n        lpa_distance: String(L_RATING_LOSSES_LOWER.lpa_distance),\\n        lpa: L_RATING_LOSSES_LOWER.lpa,\\n      };\\n\\n      return ldCustomLosses;\\n    } else {\\n      //if higer index is not found return empty dict\\n      return ldCustomLosses;\\n    }\\n  },\\n\\n  /*\\n   * This function retrieves the standard losses from Gitra Settings\\n   * or computes custom losses if not found\\n   * @params frm\\n   * @params iSetDefaultValue - \\n   * -Flag to determine if default values should be set.\\n   * @params iFieldForValidation - The name of the field to be validated.\\n   * @params iSettingsField - field name in gitra Losses child table\\n   */\\n  fnGetStandardLosses(\\n    frm,\\n    iSetDefaultValue,\\n    iFieldForValidation,\\n    iSettingsField\\n  ) {\\n    var ldDoctype = \\\"Gitra Settings\\\";\\n    frappe.model.with_doc(ldDoctype, ldDoctype, function () {\\n      const LA_VALUES = frappe.model.get_list(ldDoctype);\\n      //get the losses based on rating and transformer type\\n      var lRatingLosses = LA_VALUES[0].losses_setting.find(\\n        (x) =>\\n          x.rating === frm.doc.rating &&\\n          x.transformer_type === frm.doc.transformer_type\\n      );\\n\\n      if (!lRatingLosses) {\\n        // Calculate custom losses if rating_losses not found\\n        lRatingLosses = frm.events.fnComputeCustomLosses(\\n          frm,\\n          LA_VALUES[0].losses_setting\\n        );\\n      }\\n\\n      if (iSetDefaultValue) {\\n        frm.doc.no_load_loss_guarantee = lRatingLosses.no_load_loss;\\n        frm.doc.load_loss_guarantee = lRatingLosses.load_loss;\\n        //converted into string because 0 is not displaying\\n        frm.doc.lpa_distance = String(lRatingLosses.lpa_distance);\\n        frm.doc.lwa = lRatingLosses.lwa;\\n        frm.doc.lpa = lRatingLosses.lpa;\\n      }\\n      if (\\n        frm.doc[iFieldForValidation] > lRatingLosses[iSettingsField] &&\\n        lRatingLosses[iSettingsField] !== \\\"\\\"\\n      ) {\\n        //Format string to Camel Case(Like This String)\\n        var formattedField = iFieldForValidation\\n          .replace(/_/g, \\\" \\\")\\n          .replace(/\\\\b\\\\w/g, function (match) {\\n            return match.toUpperCase();\\n          });\\n        //the message content is updated as per the requirement below\\n        // const MESSAGE_STRING = 'Value higher than \\n        //(' + lRatingLosses[iSettingsField] +')' + ' Not Allowed';\\n        const MESSAGE_STRING =\\n        \\\"The value is higher than \\\" + lRatingLosses[iSettingsField];\\n        frappe.msgprint(MESSAGE_STRING, formattedField);\\n        // The line below is commented out because \\n        // other factories may have higher noise rates.\\n        // Therefore,requested to only \\n        // display a message (as updated above)\\n        // and allow the user to change the value\\n        // without automatically reverting it.\\n        //Restore back the field to maximum value\\n        //frm.doc[iFieldForValidation]=lRatingLosses[iSettingsField];\\n      }\\n\\n      frm.refresh_fields();\\n    });\\n  },\\n\\n  refresh(frm) {\\n    if (frm.is_new()) {\\n      frm.events.fnGetStandardLosses(frm, true);\\n    }\\n  },\\n\\n  //onchange of transformer type field\\n  transformer_type(frm) {\\n    frm.events.fnGetStandardLosses(frm, true);\\n  },\\n  //onchange of factory field\\n  factory(frm) {\\n    frm.events.fnGetStandardLosses(frm, true);\\n  },\\n  //onchange of rating field\\n  rating(frm) {\\n    frm.events.fnGetStandardLosses(frm, true);\\n  },\\n  //onchange of no load loss guarantee field\\n  no_load_loss_guarantee(frm) {\\n    frm.events.fnGetStandardLosses(\\n      frm,\\n      false,\\n      \\\"no_load_loss_guarantee\\\",\\n      \\\"no_load_loss\\\"\\n    );\\n  },\\n  //onchange of load loss guarantee field\\n  load_loss_guarantee(frm) {\\n    frm.events.fnGetStandardLosses(\\n      frm,\\n      false,\\n      \\\"load_loss_guarantee\\\",\\n      \\\"load_loss\\\"\\n    );\\n  },\\n  //onchange of lwa field\\n  lwa(frm) {\\n    frm.events.fnGetStandardLosses(frm, false, \\\"lwa\\\", \\\"lwa\\\");\\n    if (frm.doc.is_design) {\\n      // Logic to set LPA to 0 if LWA is present\\n      if (frm.doc.lwa && frm.doc.lwa !== 0) {\\n        frm.set_value(\\\"lpa\\\", 0);\\n      }\\n    }\\n  },\\n  //onchange of lpa field\\n  lpa(frm) {\\n    frm.events.fnGetStandardLosses(frm, false);\\n    if (frm.doc.is_design) {\\n      // Logic to set LWA to 0 if LPA is present\\n      if (frm.doc.lpa && frm.doc.lpa !== 0) {\\n        frm.set_value(\\\"lwa\\\", 0);\\n      }\\n    }\\n  },\\n});\\n\",\n \"view\": \"Form\"\n}","_user_tags":null,"_comments":null,"_assign":null,"_liked_by":null}